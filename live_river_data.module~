<?php

require_once DRUPAL_ROOT . '/sites/all/modules/custom/live_river_data/includes/helper.php'; 

/**
 * implement hook_menu
 */
function live_river_data_menu(){
  $item['live_river/import'] = array(
    'title' => t('Live River Data Import'),
    'page callback' => 'live_river_data_import',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $item;
}

function live_river_data_import(){
  $directory = DRUPAL_ROOT . '/sites/all/modules/custom/live_river_data/data';
  $time = date('YmdHi');
  $processed_directory = processed_directory('processed/'.$time); 
  $dir = new DirectoryIterator($directory);
  $match = '/txt$/i';
  foreach ($dir as $fileinfo){
    if(!$fileinfo->isDot()){
      if(preg_match($match, $fileinfo->getFilename())){
        $filename = $fileinfo->getPathname();
        $json = cleanInputFile($filename);
        $sites = $json->return->traces;
        process_file($sites, $filename);
        file_unmanaged_move($filename, $processed_directory, FILE_EXISTS_RENAME);
      }
    }
  }
  drupal_goto('admin/reports/dblog');
}

function live_river_data_taxonomy_creator($term_name, $vocabulary_machine_name = FALSE){
  //Grab term is it exists
  $term = taxonomy_get_term_by_name($term_name);

  // If it does not exist, make it
  if($term == array()){
    $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);
    $taxonomy = new stdClass();
    $taxonomy->name = $term_name;
    $taxonomy->vid = $vocabulary->vid;
    taxonomy_term_save($taxonomy);
    $term = taxonomy_get_term_by_name($term_name);
  }
  return key($term);
}

function process_file($sites, $filename){
  $starttime = microtime(true);
  $one_to_four = '/100to400.txt/i';
  $one_to_two  = '/100to200.txt/i';
  if(preg_match($one_to_four, $filename)){ $onetofour = TRUE; } else { $onetofour = FALSE; }
  if(preg_match($one_to_two,  $filename)){ $onetotwo  = TRUE; } else { $onetotwo  = FALSE; }

  foreach($sites as $site){
    $siteID = $site->site;
    $measurementType = $site->varto_details->short_name;
    foreach($site->trace as $values){
      $date = $values->t;
      $timestamp = strtotime($date);
      $title = date('Y-m-d-H:i',$timestamp) . ' - ' . $siteID . ' - ' . $measurementType;
      $value = $values->v;
      $quality = $values->q;
      $quality_code = $site->quality_codes->$quality;
      $siteID_tax = array('tid' => live_river_data_taxonomy_creator($siteID, 'site_id'));

      if($onetofour) {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator('Flow calculated through rating tables', 'measurement_type'));
        $title .= ' - Rating Tables';
      } elseif($onetotwo) {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator('Volume calculated through capacity tables', 'measurement_type'));
        $title .= ' - Capacity Tables';
      } else {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator($measurementType, 'measurement_type'));
      }

      $quality_tax = array('tid' => live_river_data_taxonomy_creator($quality_code, 'measurement_quality'));

      $query = new EntityFieldQuery();
      $entities = $query->entityCondition('entity_type', 'node')
        ->propertyCondition('type', 'measurement')
        ->propertyCondition('title', $title)
        ->propertyCondition('status', 1)
        ->range(0,1)
        ->execute();

      if(empty($entities['node'])){
        $node = new stdClass();  // Create new node object
        $node->type = 'measurement'; // Declare type
        node_object_prepare($node); // Set defaults
        $node->title = $title; // Set node title
        $node->language = LANGUAGE_NONE; // Set node language
        $node->uid = 1; // Set user to Admin
        $node->field_site_id[$node->language][0] = $siteID_tax;
        $node->field_measurement_type[$node->language][0] = $measurementType_tax;
        $node->field_value[$node->language][0]['value'] = $value;
        $node->field_measurement_quality[$node->language][0] = $quality_tax;
        $node->field_timestamp[$node->language][0]['value'] = $timestamp;
        if($node == node_submit($node)) {
          node_save($node);
        }
      } else {
        $nid_array = array_keys($entities['node']);
        $node = node_load($nid_array[0]);
        if($node->field_value[$node->language][0]['value'] != $value){
          $node->field_site_id[$node->language][0] = $siteID_tax;
          $node->field_measurement_type[$node->language][0] = $measurementType_tax;
          $node->field_value[$node->language][0]['value'] = $value;
          $node->field_measurement_quality[$node->language][0] = $quality_tax;
          $node->field_timestamp[$node->language][0]['value'] = $timestamp;
          if($node == node_submit($node)) {
            node_save($node);
          }
        }
      }
    }
  }
  live_river_data_delete_old($date, $measurementType_tax);
  $time_taken = microtime(true) - $starttime;
  $string = 'Proccessed: Measurement type -'.$measurementType.' ('.$filename . ') in ' . $time_taken . ' seconds';
  watchdog('Live River Data', t($string), array(), WATCHDOG_NOTICE);
}
// function to delete older records
function live_river_data_delete_old($dateString, $measurementTid) {
  $query = new EntityFieldQuery();
  $timestamp = strtotime($dateString) - 48*3600;

  $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'measurement')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_timestamp', 'value', $timestamp, '<')
    ->fieldCondition('field_measurement_type', 'tid', $measurementTid['tid']);

  $result = $query->execute();

  if(isset($result['node'])){
    $nodes_to_delete_nids = array_keys($result['node']);
    node_delete_multiple($nodes_to_delete_nids);
    $number_of_deleted_nodes = count($nodes_to_delete_nids);
    $string = $number_of_deleted_nodes . ' have been deleted due to becoming old.';
    watchdog('Live River Data', t($string), array(), WATCHDOG_NOTICE);
  }
}
