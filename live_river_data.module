<?php

require_once DRUPAL_ROOT . '/sites/all/modules/custom/live_river_data/includes/helper.php'; 

/**
 * implement hook_menu
 */
function live_river_data_menu(){
  $items = array();
  $items['live_river/import'] = array(
    'title' => t('Live River Data Import'),
    'page callback' => 'live_river_data_import',
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/content/live_river'] = array(
    'title' => 'Live River Data',
    'description' => 'Configuration for the importing of Live River Data',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('live_river_data_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Page callback: Current Live River Data import settings
 *
 * @See live_river_data_menu()
 */
function live_river_data_form($form, &$form_state){
  $form['general_settings'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#title' => t('General Seetings for Live River Data Importing'),
    '#description' => t('The Live River Data module enables the processing of Hydrasta files uploaded to a specific directory. Settings are here.'),
  );
  $form['general_settings']['live_river_data_directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Scan directory'),
    '#default_value' => variable_get('live_river_data_directory', ''),
    '#description' => t('Enter the directory where Live River Data JSON files will be uploaded to for processing.'),
    '#required' => TRUE,
  );
  $form['general_settings']['live_river_data_days_to_retain'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of Days to retain data for'),
    '#default_value' => variable_get('live_river_data_days_to_retain', '30'),
    '#description' => t('Enter the number of days that data is to be retained for in the Drupal system'),
    '#required' => TRUE,
  );
  return system_settings_form($form);
}

/**
 * Page callback: Run Live River Data Import
 *
 * @See live_river_data_menu()
 */
function live_river_data_import(){
  $directory = drupal_realpath(variable_get('live_river_data_directory', ''));
  $time = date('YmdHi');
  $processed_directory = processed_directory('processed/'.$time); 
  $dir = new DirectoryIterator($directory);
  $match = '/txt$/i';
  foreach ($dir as $fileinfo){
    if(!$fileinfo->isDot()){
      if(preg_match($match, $fileinfo->getFilename())){
        $filename = $fileinfo->getPathname();
        $json = cleanInputFile($filename);
        if($json != FALSE){
          $sites = $json->return->traces;
          _process_file($sites, $filename);
          if(file_exists($filename)){
            file_unmanaged_move($filename, $processed_directory, FILE_EXISTS_RENAME);
          }
        }
      }
    }
  }
  drupal_goto('admin/reports/dblog');
}

/**
 * Implement hook_cron().
 */
function live_river_data_cron() {
  $queue = DrupalQueue::get('liveRiverDataFile');
  foreach(filesQueueGenerator() as $file){
    $queue->createItem($file);
  }
}

/**
 * Implement hook_cron_queue_info().
 */
function live_river_data_cron_queue_info() {
  $queues = array();
  $queues['liveRiverDataFile'] = array(
    'worker callback' => 'live_river_data_processJson',
    'time' => 180,
  );
  return $queues;
}

/**
 * get files.
 * See hook_cron()
 */
function filesQueueGenerator(){
  $directory = drupal_realpath(variable_get('live_river_data_directory', ''));
  $time = date('YmdHi');
  $dir = new DirectoryIterator($directory);
  $match = '/txt$/i';
  $files = array();
  foreach ($dir as $fileinfo){
    if(!$fileinfo->isDot()){
      if(preg_match($match, $fileinfo->getFilename())){
        $filename = $fileinfo->getPathname();
        $json = cleanInputFile($filename);
        if($json != FALSE){
          $object = array($json, $filename);
          array_push($files, $object);
          if(file_exists($filename)){
            $processed_directory = processed_directory('processed/'.$time);
            file_unmanaged_move($filename, $processed_directory, FILE_EXISTS_RENAME);
          }
        }
      }
    }
  }
  return $files;
}

/**
 * Worker threads.
 */
function live_river_data_processJson($item){
  $sites = $item[0]->return->traces;
  $filename = $item[1];
  _process_file($sites, $filename);
  $message = 'Cron Processed the following file: '. $filename;
  watchdog('Live River Data', t($message), array(), WATCHDOG_NOTICE);
  return TRUE;
}

/**
 * Function to create taxonomy term and vocabulary dynamically.
 * Returns term ID
 */
function live_river_data_taxonomy_creator($term_name, $vocabulary_machine_name = FALSE){
  //Grab term is it exists
  $term = taxonomy_get_term_by_name($term_name);

  // If it does not exist, make it
  if($term == array()){
    $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);
    $taxonomy = new stdClass();
    $taxonomy->name = $term_name;
    $taxonomy->vid = $vocabulary->vid;
    taxonomy_term_save($taxonomy);
    $term = taxonomy_get_term_by_name($term_name);
  }
  return key($term);
}

/**
 * Process JSON and File
 *
 */
function _process_file($sites, $filename){
  $starttime = microtime(true);
  $one_to_four = '/100to400.txt/i';
  $one_to_two  = '/100to200.txt/i';
  if(preg_match($one_to_four, $filename)){ $onetofour = TRUE; } else { $onetofour = FALSE; }
  if(preg_match($one_to_two,  $filename)){ $onetotwo  = TRUE; } else { $onetotwo  = FALSE; }

  $siteID_check = '';
  $measurementType_check = '';

  foreach($sites as $site){
    $siteID = $site->site;
    $measurementType = $site->varto_details->short_name;

    foreach($site->trace as $values){
      if($siteID != $siteID_check) {
        $siteID_check = $siteID;
        $siteID_tax = array('tid' => live_river_data_taxonomy_creator($siteID, 'site_id'));
      }

      $date = $values->t;
      $timestamp = strtotime($date);
      $title = date('Y-m-d-H:i',$timestamp) . ' - ' . $siteID . ' - ' . $measurementType;

      $field_value = $values->v;
      // Quality TAX
      $quality = $values->q;
      $quality_codes = (array)$site->quality_codes;
      $new_qcodes = array();
      foreach($quality_codes as $key => $value){
        $new_qcodes["q".$key] = $value;
      }
      $quality_code = $new_qcodes['q'.$quality];
      $quality_tax = array('tid' => live_river_data_taxonomy_creator($quality_code, 'measurement_quality'));

      // Measurement Tax
      if($onetofour) {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator('Flow calculated through rating tables', 'measurement_type'));
        $title .= ' - Rating Tables';
      } elseif($onetotwo) {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator('Volume calculated through capacity tables', 'measurement_type'));
        $title .= ' - Capacity Tables';
      } else {
        $measurementType_tax = array('tid' => live_river_data_taxonomy_creator($measurementType, 'measurement_type'));
      }


      $query = new EntityFieldQuery();
      $entities = $query->entityCondition('entity_type', 'node')
        ->propertyCondition('type', 'measurement')
        ->propertyCondition('title', $title)
        ->propertyCondition('status', 1)
        ->range(0,1)
        ->execute();

      if(empty($entities['node'])){
        $node = new stdClass();  // Create new node object
        $node->type = 'measurement'; // Declare type
        node_object_prepare($node); // Set defaults
        $node->title = $title; // Set node title
        $node->language = LANGUAGE_NONE; // Set node language
        $node->uid = 1; // Set user to Admin
        $node->field_site_id[$node->language][0] = $siteID_tax;
        $node->field_measurement_type[$node->language][0] = $measurementType_tax;
        $node->field_value[$node->language][0]['value'] = $field_value;
        $node->field_measurement_quality[$node->language][0] = $quality_tax;
        $node->field_timestamp[$node->language][0]['value'] = $timestamp;
        if($node == node_submit($node)) {
          node_save($node);
        }
      } else {
        $nid_array = array_keys($entities['node']);
        $node = node_load($nid_array[0]);
        if($node->field_value[$node->language][0]['value'] != $value || $node->field_measurement_quality[$node->language][0] != $quality_tax){
          $node->language = LANGUAGE_NONE; // Set node language
          $node->field_site_id[$node->language][0] = $siteID_tax;
          $node->field_measurement_type[$node->language][0] = $measurementType_tax;
          $node->field_value[$node->language][0]['value'] = $field_value;
          $node->field_measurement_quality[$node->language][0] = $quality_tax;
          $node->field_timestamp[$node->language][0]['value'] = $timestamp;
          if($node == node_submit($node)) {
            node_save($node);
          }
        }
      }
    }
  }
  if(isset($date) && isset($measurementType_tax)){
    _live_river_data_delete_old($date, $measurementType_tax);
  }
  $time_taken = microtime(true) - $starttime;
  $string = 'Proccessed: Measurement type -'.$measurementType.' ('.$filename . ') in ' . $time_taken . ' seconds';
  watchdog('Live River Data', t($string), array(), WATCHDOG_NOTICE);
}

// function to delete older records
function _live_river_data_delete_old($dateString, $measurementTid) {
  $query = new EntityFieldQuery();
  $days_to_retain = variable_get('live_river_data_days_to_retain', 30);;
  $timestamp = strtotime($dateString) - ((int)$days_to_retain * 24 * 3600);

  $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'measurement')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_timestamp', 'value', $timestamp, '<=')
    ->fieldCondition('field_measurement_type', 'tid', $measurementTid['tid']);

  $result = $query->execute();

  if(isset($result['node'])){
    $nodes_to_delete_nids = array_keys($result['node']);
    node_delete_multiple($nodes_to_delete_nids);
    $number_of_deleted_nodes = count($nodes_to_delete_nids);
    $string = $number_of_deleted_nodes . ' nodes have been deleted due to becoming old.';
    watchdog('Live River Data', t($string), array(), WATCHDOG_NOTICE);
  }
}
